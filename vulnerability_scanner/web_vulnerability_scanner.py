"""
Software Vulnerability Scanner for Windows 11
Uses winreg, JSON database, regex. Detects outdated software and compares with winget.
"""
import winreg
import re
import json
import subprocess
import os
from pathlib import Path

# Registry paths for installed software (Windows 11)
UNINSTALL_PATHS = [
    (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"),
    (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"),
    (winreg.HKEY_CURRENT_USER, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"),
]

DB_PATH = Path(__file__).parent / "vulnerability_db.json"

# Regex patterns for version extraction
VERSION_PATTERNS = [
    r'(\d{1,5}\.\d{1,5}\.\d{1,5}\.\d{1,5})',   # 1.2.3.4
    r'(\d{1,5}\.\d{1,5}\.\d{1,5})',             # 1.2.3
    r'(\d{1,5}\.\d{1,5})',                       # 1.2
    r'(\d{1,5})',                                # 1
    r'(\d{4}\.\d{1,2}\.\d{1,2})',               # 2024.1.15
    r'(\d{4}\.\d{1,2})',                         # 2024.1
    r'v?(\d+\.\d+\.\d+[.\d]*)',                  # v1.2.3 or 1.2.3.4
]


def parse_version(version_str):
    """Extract normalized version tuple from version string for comparison."""
    if not version_str or not isinstance(version_str, str):
        return None
    version_str = str(version_str).strip()
    for pattern in VERSION_PATTERNS:
        match = re.search(pattern, version_str)
        if match:
            raw = match.group(1)
            parts = re.findall(r'\d+', raw)
            if parts:
                return tuple(int(p) for p in parts[:5])  # Max 5 parts
    return None


def compare_versions(v_installed, v_reference):
    """
    Compare two version tuples.
    Returns: -1 if installed < reference, 0 if equal, 1 if installed > reference
    """
    if not v_installed:
        return None  # Cannot compare
    if not v_reference:
        return 0
    for i in range(max(len(v_installed), len(v_reference))):
        a = v_installed[i] if i < len(v_installed) else 0
        b = v_reference[i] if i < len(v_reference) else 0
        if a < b:
            return -1
        if a > b:
            return 1
    return 0


def get_installed_software():
    """Enumerate all installed software from Windows registry."""
    installed = {}
    seen_keys = set()

    for hkey, base_path in UNINSTALL_PATHS:
        try:
            key = winreg.OpenKey(
                hkey, base_path, 0,
                winreg.KEY_READ | winreg.KEY_WOW64_64KEY
            )
        except (OSError, FileNotFoundError):
            try:
                key = winreg.OpenKey(
                    hkey, base_path, 0,
                    winreg.KEY_READ | winreg.KEY_WOW64_32KEY
                )
            except (OSError, FileNotFoundError):
                continue

        try:
            i = 0
            while True:
                try:
                    subkey_name = winreg.EnumKey(key, i)
                    subkey_path = base_path + subkey_name
                    if subkey_path in seen_keys:
                        i += 1
                        continue
                    seen_keys.add(subkey_path)

                    try:
                        subkey = winreg.OpenKey(key, subkey_name, 0, winreg.KEY_READ)
                        name = _get_reg_value(subkey, "DisplayName")
                        version = _get_reg_value(subkey, "DisplayVersion")
                        publisher = _get_reg_value(subkey, "Publisher")
                        winreg.CloseKey(subkey)
                    except (OSError, WindowsError):
                        i += 1
                        continue

                    if not name:
                        i += 1
                        continue

                    name = str(name).strip()
                    if name and name not in installed:
                        installed[name] = {
                            "name": name,
                            "version": str(version) if version else None,
                            "publisher": str(publisher) if publisher else None,
                            "version_tuple": parse_version(version) if version else None,
                        }
                    i += 1
                except OSError:
                    break
        finally:
            winreg.CloseKey(key)

    return list(installed.values())


def _get_reg_value(key, value_name):
    try:
        val, _ = winreg.QueryValueEx(key, value_name)
        return val
    except (OSError, WindowsError):
        return None


def load_vulnerability_db():
    """Load local JSON vulnerability database."""
    try:
        with open(DB_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
        return data.get("vulnerable_versions", {})
    except (FileNotFoundError, json.JSONDecodeError):
        return {}


def _match_software_name(installed_name, db_keys, aliases_map):
    """Try to match installed software name to vulnerability DB entry."""
    name_lower = installed_name.lower()
    for db_key in db_keys:
        if db_key.lower() in name_lower or name_lower in db_key.lower():
            return db_key
        aliases = aliases_map.get(db_key, {}).get("aliases", [])
        for alias in aliases:
            if alias.lower() in name_lower or name_lower in alias.lower():
                return db_key
    return None


def get_winget_upgrades():
    """
    Run 'winget upgrade' and parse output for available upgrades.
    Returns dict: { package_name: { "current": "x.y.z", "available": "a.b.c", "id": "..." } }
    """
    result = {}
    try:
        proc = subprocess.run(
            ["winget", "upgrade", "--accept-source-agreements", "--include-unknown"],
            capture_output=True,
            text=True,
            timeout=90,
            creationflags=subprocess.CREATE_NO_WINDOW if os.name == "nt" else 0,
        )
        out = (proc.stdout or "") + (proc.stderr or "")
        lines = out.splitlines()

        # winget table: Name  Id  Version  Available  Source (columns separated by 2+ spaces)
        # Skip header and separator lines
        version_re = re.compile(r'\d+\.\d+(?:\.\d+)*(?:\.\d+)?')
        for line in lines:
            if not line.strip() or line.startswith("----") or "Version" in line and "Available" in line:
                continue
            # Find all version-like tokens
            tokens = re.findall(r'[^\s]+', line)
            versions = [t for t in tokens if version_re.match(t)]
            if len(versions) >= 2:
                # First version = current, second = available
                cur_ver, avail_ver = versions[0], versions[1]
                # Package Id is usually Company.Package (e.g. Google.Chrome)
                id_candidates = [t for t in tokens if '.' in t and not version_re.match(t)]
                pkg_id = id_candidates[0] if id_candidates else ""
                # Name is everything before the Id (first token(s) before Company.Package)
                name_tokens = []
                for t in tokens:
                    if t in versions or (pkg_id and t == pkg_id):
                        break
                    name_tokens.append(t)
                name = " ".join(name_tokens).strip()
                if name and avail_ver:
                    result[name] = {
                        "current": cur_ver,
                        "available": avail_ver,
                        "id": pkg_id,
                    }
                    # Also add by Id for matching
                    if pkg_id and pkg_id not in result:
                        result[pkg_id] = result[name]
    except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
        pass
    return result


def compute_risk_score(software, vuln_db, winget_upgrades):
    """
    Compute risk score 0-100 based on:
    - Known vulnerability in DB
    - Version behind critical/high/medium thresholds
    - Update available from winget
    """
    score = 0
    reasons = []
    name = software.get("name", "")
    version = software.get("version") or ""
    version_tuple = software.get("version_tuple")

    # 1. Check vulnerability database
    db_key = _match_software_name(name, vuln_db.keys(), vuln_db)
    if db_key:
        entry = vuln_db[db_key]
        cve_count = entry.get("cve_count", 0)
        for level, key in [("critical", "critical_before"), ("high", "high_before"), ("medium", "medium_before")]:
            ref = entry.get(key)
            if ref:
                ref_tuple = parse_version(ref)
                cmp = compare_versions(version_tuple, ref_tuple)
                if cmp is not None and cmp < 0:
                    if level == "critical":
                        score = max(score, 90)
                        reasons.append(f"Critical: version older than {ref} (CVEs known)")
                    elif level == "high":
                        score = max(score, 70)
                        reasons.append(f"High: version older than {ref} (CVEs known)")
                    elif level == "medium":
                        score = max(score, 50)
                        reasons.append(f"Medium: version older than {ref} (CVEs known)")
                    break

        if score == 0 and cve_count > 0:
            reasons.append(f"In vulnerability DB ({cve_count} CVEs tracked)")
            score = max(score, 30)

    # 2. Check winget for available update
    winget_match = None
    for wg_name, wg_data in winget_upgrades.items():
        if name.lower() in wg_name.lower() or wg_name.lower() in name.lower():
            winget_match = wg_data
            break

    if winget_match:
        avail = winget_match.get("available", "")
        cur = winget_match.get("current", "")
        if avail and (not cur or parse_version(cur) != parse_version(avail)):
            if score < 50:
                score = max(score, 40)
            reasons.append(f"Update available: {avail} (via winget)")

    if not reasons:
        reasons.append("No known issues")

    return min(100, score), reasons


def get_risk_level(score):
    if score >= 70:
        return "critical"
    if score >= 50:
        return "high"
    if score >= 30:
        return "medium"
    if score >= 10:
        return "low"
    return "info"


def scan_for_web():
    """Main scan function for web interface."""
    result = {
        "status": "success",
        "installed": [],
        "outdated": [],
        "risk_summary": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
        "total_installed": 0,
        "total_outdated": 0,
        "winget_available": False,
        "error": None,
    }

    try:
        vuln_db = load_vulnerability_db()
        winget_upgrades = get_winget_upgrades()
        result["winget_available"] = len(winget_upgrades) > 0

        installed = get_installed_software()
        result["total_installed"] = len(installed)

        outdated = []
        for sw in installed:
            score, reasons = compute_risk_score(sw, vuln_db, winget_upgrades)
            level = get_risk_level(score)
            result["risk_summary"][level] += 1

            # Get latest from winget if available
            latest_version = None
            winget_id = None
            for wg_name, wg_data in winget_upgrades.items():
                if sw["name"].lower() in wg_name.lower() or wg_name.lower() in sw["name"].lower():
                    latest_version = wg_data.get("available")
                    winget_id = wg_data.get("id")
                    break

            item = {
                "name": sw["name"],
                "version": sw["version"],
                "publisher": sw["publisher"],
                "risk_score": score,
                "risk_level": level,
                "reasons": reasons,
                "latest_version": latest_version,
                "winget_id": winget_id,
            }

            result["installed"].append(item)
            if score >= 30 or latest_version:
                outdated.append(item)

        result["outdated"] = sorted(outdated, key=lambda x: -x["risk_score"])
        result["total_outdated"] = len(outdated)

    except Exception as e:
        result["status"] = "error"
        result["error"] = str(e)

    return result
